#!/usr/bin/env python

'''
Use multiprocessing and subprocess and Beej's 
Python Flickr API to search & retrieve station photos

@package  Datascope
@author   Rob Newman <robertlnewman@gmail.com> 858.822.1333
@version  1.2
@modified 2011-07-14
@license  MIT-style license
@notes    Cannot use multiprocessing.Lock() due to Python 
          issue 3770. Will result in the following output:
          'ImportError: This platform lacks a functioning 
          sem_open implementation, therefore, the required 
          synchronization primitives needed will not 
          function, see issue 3770.'
'''

# Import modules
import sys
import os
import glob
import json
import multiprocessing
import subprocess
from time import time, gmtime, strftime, strptime, mktime
from optparse import OptionParser
# For Flickr queries
import flickrapi
import urllib2
# For Antelope
sys.path.append( os.environ['ANTELOPE'] + '/local/data/python/antelope' )
import datascope
from stock import pfupdate, pfget

# Get command line arguments
usage = "Usage: %prog [options]"
parser = OptionParser(usage=usage)
parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help="verbose output", default=False)
parser.add_option("-s", "--station", action="store", dest="station_override", help="station override", default=False)
parser.add_option("-t", "--type", action="store", type="string", dest="qtype", help="type of Flickr query", default=False)
parser.add_option("-x", "--debug", action="store_true", dest="debug", help="debug script", default=False)
(options, args) = parser.parse_args()
if options.verbose:
    verbose = True
else:
    verbose = False
if options.station_override:
    station = options.station_override
else:
    station = False
if options.qtype:
    qtype = options.qtype
else:
    qtype = False
if options.debug:
    debug = options.debug
else:
    debug = False

# Get config parameter file vars
common_pf = 'common.pf'
pfupdate(common_pf)
cache_json = pfget(common_pf, 'CACHEJSON')
dbmaster = pfget(common_pf, 'USARRAY_DBMASTER')
photo_path = pfget(common_pf, 'CACHE_TOP_PICK')
admin_email = pfget(common_pf, 'admin_email')
json_file_path = '%s/stations/stations.json' % cache_json

# Variables
api_key = '12d733afde188c65c8dd8683df7f12e2'
api_secret = 'e6244353de4f3361'
token = '833039-37f3537105cfcd72'
myid = '30452022@N00'
all_tags = ['top_pick','LN','LW','LE','LS']
flickr_url_path = "http://farm%s.static.flickr.com/%s/%s_%s.jpg"
tester_tags = {
    'before': ('_before', 'TA_'),
    'after': ('_after', 'TA_'),
    'simple': ('', 'TA_'),
    'none': ('', '')
}
flickr = flickrapi.FlickrAPI(api_key, api_secret, token=token)
sendmail='/usr/sbin/sendmail'
num_processes = int(multiprocessing.cpu_count()/3) # Be nice & only use a third of available processors
then = time() - 604800 # Within the last week ago
if debug:
    recipients = admin_email
else:
    recipients = '%s,hafner@iris.edu,reyes@ucsd.edu' % admin_email # Comma seperated list
sys.path.append(os.getcwd() + '/bin/py_flickr_1.1/')

def time_test(my_sta_dict, sta_type):
    """Does the station 
    (only AZ or TA right now)
    pass the time test?
    """
    if my_sta_dict['snet'] == 'TA' or my_sta_dict['snet'] == 'AZ':
        try:
            struct_time = strptime(my_sta_dict["decert_time"], "%Y-%m-%d %H:%M:%S")
        except ValueError:
            print "   - Time %s cannot be converted to a struct_time" % my_sta_dict["decert_time"]
        else:
            if mktime(struct_time) > then:
                return True
    return False

def build_stalist(json_dict):
    """Parse the JSON file dict and
    return list of all stations in reverse
    order for the pop() later
    """
    sta_list = []
    if qtype == 'adopt' or qtype == 'decom':
        for sta_name in json_dict[qtype]:
            sta_list.append(sta_name)
    else:
        for sta_type in json_dict:
            for sta_name in json_dict[sta_type]:
                if qtype == 'all':
                    print " - Getting photos for ALL stations (decom, adopt and active)"
                    sta_list.append(sta_name)
                else:
                    if sta_type == 'adopt' or sta_type == 'decom':
                        if time_test(json_dict[sta_type][sta_name], sta_type):
                            sta_list.append(sta_name)
                    else:
                        sta_list.append(sta_name)
    sta_list.sort(reverse=True)
    return sta_list

def json_stalist(json_file):
    """Get a list of stations
    from the JSON file specified
    """
    file_pointer = open(json_file,'r').read()
    my_json_obj = json.loads(file_pointer)
    json_sta_list = build_stalist(my_json_obj)
    return json_sta_list

def per_sta_query(staname, conn=False):
    """Create a subprocess
    for the selected station
    """
    try:
        retcode = flickr_photo_retrieval(staname)
    except OSError:
        retcode = " - Subprocess execution failed for station %s" % staname
    conn.send(retcode)
    conn.close()

def flickr_tag_precedence(tag, sta):
    """Search photos tagged in Flickr
    and return in order of precedence
    """
    result_tags = {}
    for k,v in tester_tags.iteritems():
        tag1_suffix = v[0]
        tag2_prefix = v[1]
        try: 
            search = flickr.photos_search(user_id=myid, tags=tag+tag1_suffix+', '+tag2_prefix+sta, tag_mode='all', per_page='10')
        except flickr.FlickrError:
            print "  - Flickr photo search for tags '%s%s, %s%s' has encountered an error - skipping this query" % (tag, tag1_suffix, tag2_prefix, sta)
        else:
            if hasattr(search.photos[0], 'photo'):
                if debug:
                    print "  - Flickr photo search for tag '%s%s, %s%s' matched a photo" % (tag, tag1_suffix, tag2_prefix, sta)
                result_tags[k] = (tag1_suffix, tag2_prefix)
    # Precedence
    if 'before' in result_tags:
        return [ tag+result_tags['before'][0], result_tags['before'][1]+sta ]
    elif 'after' in result_tags:
        return [ tag+result_tags['after'][0], result_tags['after'][1]+sta ]
    elif 'simple' in result_tags:
        return [ tag+result_tags['simple'][0], result_tags['simple'][1]+sta ]
    elif 'none' in result_tags:
        return [ tag+result_tags['none'][0], result_tags['none'][1]+sta ]
    else:
        raise TypeError('No matching photos for any of the tag selections.')

def delete_local_flickr_img(img_path, img_id):
    """Use glob to delete any pre-existing file for 
    this image that does not match the one about to 
    be downloaded
    """
    response_list = []
    for entry in glob.glob(img_path):
        if(entry.count(img_id) == 0 ):
            response_list.append("  - Warning: Pre-existing file %s that is no longer valid. Deleting...\n" % entry)
            try:
                os.remove(entry)
            except OSError, e:
                response_list.append("  - Error: %s occurred when trying to delete the file %s\n" % (e.errno, entry))
        else:
            statinfo = os.stat(entry)
            if( statinfo.st_size < 1 ):
                response_list.append("  - Warning: Pre-existing file %s has a file size of zero! Deleting...\n" % entry)
                try:
                    os.remove(entry)
                except OSError, e:
                    response_list.append("  - Error: %s occurred when trying to delete the file %s\n" % (e.errno, entry))

    if len(response_list) > 0 and verbose:
        response_str = "".join(response_list)
        return response_str
    else:
        return ""

def download_flickr_img(img_path, photo):
    """Attempt to download the photo from 
    Flickr to a local file system
    """
    response_list = []
    if not os.path.exists(img_path):
        my_file = flickr_url_path % (photo['farm'], photo['server'], photo['id'], photo['secret'])
        try:
            downloaded = urllib2.urlopen(my_file).read()
        except urllib2.URLError:
            print urllib2_URLError
        except:
            response_list.append("  - Unknown saving error for %s\n" % my_file)
        else:
            save = open(img_path, 'wb')
            savestr = str(downloaded)
            save.write(savestr)
            save.close()
            response_list.append('  - Saving photo: %s\n' % my_file)
    else:
        response_list.append('  - Image %s already exists. Ignoring.\n' % img_path)
    if len(response_list) > 0 and verbose:
        response_str = "".join(response_list)
    if verbose:
        print response_str
    return response_str

def flickr_photo_retrieval(sta):
    """Grab the matching photo
    from Flickr
    """
    query_output = []
    photo_obj = {}
    for i in range(len(all_tags)):
        try:
            the_auth_tag, the_sta_tag = flickr_tag_precedence(all_tags[i], sta)
        except TypeError as e:
            print '  - No photo for %s: %s. Error: %s' % (sta, all_tags[i], e)
            query_output.append('  - No photo for %s: %s\n' % (sta, all_tags[i]))
        else:
            if debug:
                print '  - Using tags %s, %s' % (the_auth_tag, the_sta_tag)
            mytags = '%s, %s' % (the_sta_tag, the_auth_tag)
            try:
                search = flickr.photos_search(user_id=myid, tags=mytags, tag_mode='all', per_page='10')
            except AttributeError, e:
                print "AttributeError: %s" % e
            except IOError, e:
                print "IOError: %s" % e
            else:
                if len(search.photos) > 1:
                    print "  - Warning: %d different photos match the tag query %s. This will cause duplication errors. Please fix." % (len(search.photos), mytags)
                # Grab all matching photos
                try:
                    photo = search.photos[0].photo[0]
                except AttributeError, e:
                    print "Attribute Error: %s" % e
                except IOError, e:
                    print "IOError: %s" % e
                else:
                    img = '%s/%s_%s_%s.jpg' % (photo_path, sta, all_tags[i], photo['id'])
                    greedy_file_search = '%s/%s*_%s_*.jpg' % (photo_path, sta, all_tags[i])
                    query_output.append(delete_local_flickr_img(greedy_file_search, photo['id']))
                    query_output.append(download_flickr_img(img, photo))
    if len(query_output) > 0 and verbose:
        query_str = "".join(query_output)
        return query_str
    else:
        return "   - Complete...\n"

def main():
    """Grab & parse station list
    then run subprocesses to 
    grab photos from Flickr
    """
    t0 = strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
    if station:
        file_sta_list = [station]
    else:
        file_sta_list = json_stalist(json_file_path)
    threads = []
    if verbose:
        print '- Flickr Python Photo Downloader started at %s' % t0
        print ' - Checking TA stations...\n - Email will be sent to: %s' % recipients
        print ' - Number of processes: %s' % num_processes
        print ' - Number of stations to process: %s' % len(file_sta_list)
    out_str = '- Flickr Python Photo Downloader started at %s\n - Checking TA stations...\n' % t0
    while threads or file_sta_list:
        if (len(threads) < num_processes) and file_sta_list:
            mysta = file_sta_list.pop()
            if verbose:
                print '\n - Station %s' % mysta
            out_str += '\n - Station %s\n' % mysta
            parent_conn, child_con = multiprocessing.Pipe()
            p = multiprocessing.Process(target=per_sta_query, args=[mysta, child_con])
            p.start()
            threads.append(p)
            try:
                ret_vals = parent_conn.recv()
                out_str += ret_vals
                p.join()
            except TypeError as type_err:
                out_str += "Station %s: Connection recv() type error: %s\n" % (mysta, type_err)
        else:
            for thread in threads:
                if not thread.is_alive():
                    threads.remove(thread)
    t1 = strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
    if verbose:
        print ' - All TA stations checked...'
        print '- Flickr Python Photo Downloader finished at %s' % t1
    out_str += ' - All TA stations checked. Goodbye..\n'
    out_str += '- Flickr Python Photo Downloader finished at %s' % t1
    # Sendmail command
    sm = os.popen("%s -t" % sendmail, 'w' ) 
    sm.write("To: %s\n" % recipients )
    sm.write("Subject: Flickr photo archive retrieval output\n")
    sm.write(out_str)
    exitcode = sm.close()
    if exitcode:
        print "Exit code: %s" % exitcode

if __name__ == '__main__':
    main()
